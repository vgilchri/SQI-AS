
load "src/sqisign.m";

// generate hard relation from same base curve as sqisign: 
// (witness, relation) = (y, [E_y, P_y, Q_y]: E_y = E_0 / <P_y + y Q_y>), degree power of 3 (hard coded for now)
// look at how commitment is generated in sqisign.m and sidh

// compute the commitment extension
// the degree of the challenge isogeny is hardcoded in this function

sqi_presign := function(sk,pk,K,phi_K,isom_K,J,phi_J,epsilon)
	order:=O0;
	B<i,j,k>:=Parent(Basis(order)[1]);
	w1 := i;
	w2 := j;
	// signing_odd_torsion:=3^53*5^21; //should not be bigger than p/N
	signing_odd_torsion:=1;

	message := [Random(1,2^32-1),Random(1,2^64-1) ];
		//generate  challenge + commitment
		t:=ClockCycles();
		commitment,phi_commit,phi_commit_dual,I_commit:=gen_commitment_odd();
		commit_time:=timediff(t);
		tt:=ClockCycles();
		
		// pick random int from Z_p
		c := Random(1,p);
		
		// compute isogeny from E_1 to E_1 / (P_y + c Q_y)
		// find its degree
		// compute the kernel generator
		ker_ext:= Evaluate(phi_commit,P_y + c*Q_y);
		// find the order of the kernel generator
		ker_ext_deg := Order(ker_ext);
		
	// compute the commitment extension
		phi_ext := BigIsogeny(ker_ext, ker_ext_deg)
		phi_ext_dual := dual_odd_isogeny(phi_ext, ker_ext);
		
		// how to factor ker_ext_deg?????????????????????????????????????????????????? if we choose P_y and Q_y to be power of 3, then phi_ext also be power of 3
		z=0;
		checker := 1;
		repeat
			checker := checker*3;
			z +:= 1;		
		until checker eq ker_ext_deg;		
		
		// ker = ker_ext?? P, Q = phi(P_y), phi(Q_y)??
		phi_ext_I := kernel_to_ideal_O0_prime_power(3,z,ker,P,Q);
		
		// compose the commitment with this new extension to get new input for next line...compose duals? dual_two_isogenies_kernel:=function(isogenies,kernel)		new_commit, new_commit_dual := 
//the challenge uses the 128 bits of 3 and 5 torsions
// the commitment needs to have 256 bits at least, this is obtained by taking all the remaining odd torsion
		
		phi_chall,chall,H_chall:=gen_honest_challenge_prover(phi_ext_dual,phi_ext_I,message);
		challenge_time :=timediff(tt);
		
		// compose phi_commit and phi_ext, make this the new phi_commit
		// line 79 uses 'cat' with two isogenies....is this composition?
		commitment,phi_commit,phi_commit_dual,I_commit:= phi_ext`codomain, phi_commit cat phi_ext, phi_ext_dual cat phi_commit_dual , I_commit*phi_ext_I;

		//generate the signature ideal
		tt:=ClockCycles();
		equivalent_ideal:=small_equivalent_ideal(Conjugate(sk)*H_chall);
		_,alpha:=LeftIsomorphism(J,sk);
		sign_ideal:=QuaternionIsogenyPath_special_Extended2(order,w1,w2,equivalent_ideal,sk,2:addit_factor:=signing_odd_torsion);
		sign_ideal:=cyclic_ideal(sign_ideal:full:=true);
		klpt_time:=timediff(tt);
		sign_ideal:=sign_ideal*lideal<RightOrder(sign_ideal)|Conjugate(alpha)/Norm(alpha)>;
		sign_ideal:=rideal<LeftOrder(sign_ideal)|alpha>*sign_ideal;

		//computing the signature isogeny
		tt:=ClockCycles();
		sign_isogeny,sign_isom,_:=ideal_to_isogeny_power_of_two(sign_ideal,J,K,phi_J,phi_K,isom_K,epsilon:other_side_isogeny:=phi_commit cat phi_chall,other_side_ideal:=H_chall);
		 // sign_isogeny,sign_isom,_:=ideal_to_isogeny_power_of_two(J*sign_ideal,J,K,phi_J,phi_K,isom_K,epsilon);
		 translate_time:=timediff(tt);
		//normalizing and compressing
		walk, zip, last_step,len:=normalized_two_walk(sign_isogeny,sign_isom);
		sign_time:=timediff(t);

		//computing the verification
		tt:=ClockCycles();
		ver:=verify(commitment,message,zip,pk,len,last_step);
		assert(ver);
		if not ver then "problem with the verification"; end if;
		verif_time:=timediff(tt);
		
		// evaluate the secret isogeny at the two generator points of the hard relation for use in sqi_adapt
		tao_P := Evaluate(sk, P_y);
		tao_Q := Evaluate(sk, Q_y);

	return commit_time,challenge_time,klpt_time,translate_time,sign_time,verif_time,Valuation(Z!Norm(sign_ideal),2), tao_P, tao_Q;
end function;

// (witness, relation) = (y, [E_y, P_y, Q_y]: E_y = E_0 / <P_y + y Q_y>), degree power of 3 (hard coded for now)

sqi_adapt:=function(wit, presig,sk)

	// compute beta, using the witness
	// determine kernel generator
	ker_beta := tao_P + wit*tao_Q;
	// find order of kernel generator
	deg_beta := Order(ker_beta);
	//compute isogeny
	beta := BigIsogeny(ker_beta, deg_beta);
	
	// compute beta_dual
	beta_dual:=dual_odd_isogeny(beta, ker_beta);
	
	// compose presig ideal with beta dual ideal
	// run KLPT on this ideal
	// convert to isogeny
	full_sig := ;

end function;

sqi_extract:= function(presig, sig)

	// compose presig ideal with sig dual ideal 
	// run KLPT to get single ideal back
	// convert this to isogeny
	// from this extract the kernel generator

end function;

